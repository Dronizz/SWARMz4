# PX4 Multi-Drone Control System

A ROS 2 package providing high-level control interfaces for multiple PX4-powered drones, supporting both North-East-Down (NED) and Forward-Right-Down (FRD) coordinate frames.

## Features

- Multiple coordinate frame support:
  - NED (North-East-Down) for global navigation
  - FRD (Forward-Right-Down) for relative movement
- Multi-drone mission execution
- YAML-based mission configuration
- Automatic takeoff and landing
- Position holding with drift compensation
- Configurable hover times at waypoints
- Action Server and Topic interfaces
- Comprehensive error handling and retry logic
- Progress monitoring and feedback

## Prerequisites

- ROS 2 (Tested on Humble)
- PX4 Autopilot (SITL or hardware)
- px4_msgs package
- px4_controllers_interfaces package with:
  - PointYaw.msg
  - GotoPosition.action

## Installation

1. Clone this repository into your ROS 2 workspace:
```bash
cd ~/ros2_ws/src
git clone <repository_url>
```

2. Build the package:
```bash
cd ~/ros2_ws
colcon build --packages-select offboard_control_py px4_controllers_interfaces
```

3. Source the workspace:
```bash
source install/setup.bash
```

## Usage

### 1. Basic Control with NED Frame

Launch a single drone controller:
```bash
ros2 launch offboard_control_py offboard_control.launch.py team_id:=1 controller_type:=NED
```

Send position commands:
```bash
# Using action server (recommended)
ros2 action send_goal /px4_1/goto_position px4_controllers_interfaces/action/GotoPosition "{target: {position: {x: 5.0, y: 0.0, z: -2.0}, yaw: 0.0}}"

# Using topic interface
ros2 topic pub /px4_1/target_pose px4_controllers_interfaces/msg/PointYaw "{position: {x: 5.0, y: 0.0, z: -2.0}, yaw: 0.0}"
```

### 2. Relative Movement with FRD Frame

Launch with FRD controller:
```bash
ros2 launch offboard_control_py offboard_control.launch.py team_id:=1 controller_type:=FRD
```

Send relative movement commands:
```bash
# Move 5 meters forward
ros2 action send_goal /px4_1/goto_position px4_controllers_interfaces/action/GotoPosition "{target: {position: {x: 5.0, y: 0.0, z: 0.0}, yaw: 0.0}}"

# Move 3 meters right and up 1 meter with 90° rotation
ros2 action send_goal /px4_1/goto_position px4_controllers_interfaces/action/GotoPosition "{target: {position: {x: 0.0, y: 3.0, z: -1.0}, yaw: 90.0}}"
```

### 3. Multi-Drone Missions

1. Create a mission file (e.g., `missions/my_mission.yaml`):
```yaml
"1": [  # Drone 1 waypoints
  {x: 5.0, y: 0.0, z: -2.0, yaw: 90.0, time: 5.0},
  {x: 5.0, y: 5.0, z: -2.0, yaw: 180.0, time: 3.0}
]
"2": [  # Drone 2 waypoints
  {x: -5.0, y: 0.0, z: -2.0, yaw: -90.0, time: 5.0},
  {x: -5.0, y: -5.0, z: -2.0, yaw: -180.0, time: 3.0}
]
```

2. Launch the mission:
```bash
ros2 run offboard_control_py offboard_control_client --ros-args -p mission_file:=my_mission.yaml
```

## Configuration

### 1. Spawn Positions (`config/spawn_position.yaml`)
This file is automatically generated each time `launch_game.sh` is run. The script:
- Generates random spawn positions for each team within their designated field areas
- Team 1 spawns in the first 20% of field length
- Team 2 spawns in the last 20% of field length
- Drones within each team are arranged in a line with 2m spacing
- Transforms Gazebo coordinates to NED frame coordinates
- Updates the YAML file with the new positions

Example of generated spawn positions:
```yaml
"1": {  # Team 1
  "1": {x: 0.0, y: 0.0, yaw: 0.0},  # Drone 1
  "2": {x: 2.0, y: 0.0, yaw: 0.0}   # Drone 2
}
```

Manual editing of this file is not recommended as it will be overwritten on the next launch.

### 2. Controller Configuration (`config/controller_config.yaml`)
```yaml
"1": {  # Team 1
  "1": "NED",  # Drone 1 uses NED frame
  "2": "FRD"   # Drone 2 uses FRD frame
}
```

## Launch Files

1. `offboard_control.launch.py`: Basic controller launch
   ```bash
   ros2 launch offboard_control_py offboard_control.launch.py \
     team_id:=1 \
     controller_type:=NED \
     config_file:=my_config.yaml \
     spawn_file:=my_spawn.yaml
   ```

2. `game_test.launch.py`: Complete test environment
   ```bash
   ros2 launch offboard_control_py game_test.launch.py
   ```

## Node Types

1. **NED Controller** (`offboard_control_ned`):
   - Global position control
   - Uses North-East-Down coordinates
   - Best for absolute positioning

2. **FRD Controller** (`offboard_control_frd`):
   - Relative position control
   - Uses Forward-Right-Down coordinates
   - Best for relative movements

3. **Mission Control** (`offboard_control_client`):
   - Multi-drone mission execution
   - YAML mission configuration
   - Progress monitoring

## Coordinate Systems

1. **NED Frame**:
   - X: North (positive)
   - Y: East (positive)
   - Z: Down (positive)
   - Yaw: 0° = North, 90° = East

2. **FRD Frame**:
   - X: Forward (drone's heading)
   - Y: Right (relative to heading)
   - Z: Down (positive)
   - Yaw: Relative to current heading

## Advanced Usage

### Velocity Control
The `offboard_control_vel` node provides direct velocity control for PX4 drones. It supports:

1. Control Modes:
   - Position holding when zero velocity commanded
   - Pure velocity control using cmd_vel
   - Automatic takeoff and landing sequences

2. Parameters:
   ```yaml
   max_horizontal_speed: 12.0     # Maximum horizontal velocity (m/s)
   max_vertical_speed: 12.0       # Maximum vertical velocity (m/s)
   max_yaw_rate: 10.0            # Maximum yaw rate (rad/s)
   velocity_timeout: 2.0          # Time before zeroing velocity (s)
   frame_type: 'FLU'             # Reference frame (FLU/FRD/NED)
   takeoff_height: 2.0           # Target takeoff height (m)
   hover_timeout: 10.0           # Hover time before auto-land (s)
   land_height_threshold: 1.0    # Height to trigger landing (m)
   ```

3. Reference Frames:
   - FLU (Forward-Left-Up):
     ```python
     # Forward is drone's nose, Left is port side, Up is skyward
     cmd_vel.linear.x = 1.0  # Forward velocity
     cmd_vel.linear.y = -1.0 # Left velocity
     cmd_vel.linear.z = -1.0 # Up velocity
     ```
   
   - FRD (Forward-Right-Down):
     ```python
     # Forward is drone's nose, Right is starboard, Down is earthward
     cmd_vel.linear.x = 1.0  # Forward velocity
     cmd_vel.linear.y = 1.0  # Right velocity
     cmd_vel.linear.z = 1.0  # Down velocity
     ```
   
   - NED (North-East-Down):
     ```python
     # North is global North, East is global East, Down is earthward
     cmd_vel.linear.x = 1.0  # North velocity
     cmd_vel.linear.y = 1.0  # East velocity
     cmd_vel.linear.z = 1.0  # Down velocity
     ```

4. Safety Features:
   - Automatic position holding when no commands received
   - Velocity command timeout
   - Maximum speed limits
   - Auto-landing when near ground
   - Auto-disarm after landing

5. Usage Example:
   ```bash
   # Launch velocity controller
   ros2 launch offboard_control_py offboard_control.launch.py \
     team_id:=1 controller_type:=VEL frame_type:=FLU

   # Send velocity commands
   ros2 topic pub /px4_1/cmd_vel geometry_msgs/msg/Twist \
     "{linear: {x: 1.0, y: 0.0, z: 0.0}, angular: {z: 0.0}}"
   ```

### Mission Control System
The `offboard_control_client` demonstrates how to control multiple drones using ROS2 action clients. Here's how it works:

1. Action Interface:
```python
# Each drone exposes an action server at:
# /px4_{drone_id}/goto_position

# Action Definition (GotoPosition.action):
# Goal: Target position and yaw
geometry_msgs/Point position  # x, y, z in meters
float32 yaw                  # degrees

# Feedback: Current status
geometry_msgs/Point current_position
float32 distance_to_target
float32 time_elapsed

# Result: Success status
bool success
```

2. Basic Usage in Your Code:
```python
from rclpy.action import ActionClient
from px4_controllers_interfaces.action import GotoPosition

class YourController:
    def __init__(self, node):
        # Create action client for each drone
        self.client = ActionClient(
            node,
            GotoPosition,
            '/px4_1/goto_position'  # For drone 1
        )
        
    async def send_goal(self, x, y, z, yaw):
        # Wait for action server
        self.client.wait_for_server()
        
        # Create goal
        goal = GotoPosition.Goal()
        goal.target.position.x = x
        goal.target.position.y = y
        goal.target.position.z = z
        goal.target.yaw = yaw
        
        # Send goal with callbacks
        self._send_goal_future = await self.client.send_goal_async(
            goal,
            feedback_callback=self.feedback_callback
        )
        
    def feedback_callback(self, feedback_msg):
        # Process feedback
        fb = feedback_msg.feedback
        print(f"Distance to target: {fb.distance_to_target}")
```

3. Error Handling Pattern:
```python
def send_goal_with_retry(self, x, y, z, yaw, max_retries=3):
    for attempt in range(max_retries):
        try:
            response = await self.send_goal(x, y, z, yaw)
            if response.accepted:
                return await response.get_result()
            else:
                print(f"Goal rejected, attempt {attempt + 1}")
        except Exception as e:
            print(f"Error: {e}, attempt {attempt + 1}")
    return None
```

4. Multiple Drone Control:
```python
class MultiDroneController:
    def __init__(self, node, drone_ids):
        self.clients = {}
        for drone_id in drone_ids:
            self.clients[drone_id] = ActionClient(
                node,
                GotoPosition,
                f'/px4_{drone_id}/goto_position'
            )
    
    async def move_formation(self, positions):
        # Send goals to all drones simultaneously
        tasks = []
        for drone_id, pos in positions.items():
            goal = GotoPosition.Goal()
            goal.target.position.x = pos['x']
            goal.target.position.y = pos['y']
            goal.target.position.z = pos['z']
            goal.target.yaw = pos['yaw']
            
            client = self.clients[drone_id]
            tasks.append(client.send_goal_async(goal))
            
        # Wait for all goals to complete
        results = await asyncio.gather(*tasks)
        return results
```

5. Integration Example:
```python
import rclpy
from rclpy.node import Node
import asyncio

class YourMissionController(Node):
    def __init__(self):
        super().__init__('your_mission_controller')
        self.drone_controller = MultiDroneController(
            self, 
            drone_ids=['1', '2']
        )
        
    async def run_mission(self):
        # Example formation movement
        positions = {
            '1': {'x': 5.0, 'y': 0.0, 'z': -2.0, 'yaw': 0.0},
            '2': {'x': 5.0, 'y': 2.0, 'z': -2.0, 'yaw': 0.0}
        }
        results = await self.drone_controller.move_formation(positions)
        
        # Check results
        for drone_id, result in zip(positions.keys(), results):
            if result.accepted:
                print(f"Drone {drone_id} goal accepted")
            else:
                print(f"Drone {drone_id} goal rejected")

def main():
    rclpy.init()
    controller = YourMissionController()
    
    # Run async mission
    asyncio.run(controller.run_mission())
    
    rclpy.shutdown()
```